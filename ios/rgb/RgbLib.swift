// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(rgb_libFFI)
import rgb_libFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_rgb_lib_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_rgb_lib_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol BlindedUTXOProtocol {
    
}

public class BlindedUtxo: BlindedUTXOProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`blindedUtxo`: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_constructor_blindedutxo_new(
        FfiConverterString.lower(`blindedUtxo`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_rgb_lib_fn_free_blindedutxo(pointer, $0) }
    }

    

    
    
}

public struct FfiConverterTypeBlindedUTXO: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = BlindedUtxo

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlindedUtxo {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: BlindedUtxo, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> BlindedUtxo {
        return BlindedUtxo(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: BlindedUtxo) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeBlindedUTXO_lift(_ pointer: UnsafeMutableRawPointer) throws -> BlindedUtxo {
    return try FfiConverterTypeBlindedUTXO.lift(pointer)
}

public func FfiConverterTypeBlindedUTXO_lower(_ value: BlindedUtxo) -> UnsafeMutableRawPointer {
    return FfiConverterTypeBlindedUTXO.lower(value)
}


public protocol InvoiceProtocol {
    func `invoiceData`()   -> InvoiceData
    func `invoiceString`()   -> String
    
}

public class Invoice: InvoiceProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`invoiceString`: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_constructor_invoice_new(
        FfiConverterString.lower(`invoiceString`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_rgb_lib_fn_free_invoice(pointer, $0) }
    }

    

    public static func `fromInvoiceData`(`invoiceData`: InvoiceData) throws -> Invoice {
        return Invoice(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_constructor_invoice_from_invoice_data(
        FfiConverterTypeInvoiceData.lower(`invoiceData`),$0)
})
    }

    

    
    

    public func `invoiceData`()  -> InvoiceData {
        return try!  FfiConverterTypeInvoiceData.lift(
            try!
    rustCall() {
    
    uniffi_rgb_lib_fn_method_invoice_invoice_data(self.pointer, $0
    )
}
        )
    }

    public func `invoiceString`()  -> String {
        return try!  FfiConverterString.lift(
            try!
    rustCall() {
    
    uniffi_rgb_lib_fn_method_invoice_invoice_string(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeInvoice: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Invoice

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Invoice {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Invoice, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Invoice {
        return Invoice(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Invoice) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeInvoice_lift(_ pointer: UnsafeMutableRawPointer) throws -> Invoice {
    return try FfiConverterTypeInvoice.lift(pointer)
}

public func FfiConverterTypeInvoice_lower(_ value: Invoice) -> UnsafeMutableRawPointer {
    return FfiConverterTypeInvoice.lower(value)
}


public protocol TransportEndpointProtocol {
    func `transportType`()   -> TransportType
    
}

public class TransportEndpoint: TransportEndpointProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`transportEndpoint`: String) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_constructor_transportendpoint_new(
        FfiConverterString.lower(`transportEndpoint`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_rgb_lib_fn_free_transportendpoint(pointer, $0) }
    }

    

    
    

    public func `transportType`()  -> TransportType {
        return try!  FfiConverterTypeTransportType.lift(
            try!
    rustCall() {
    
    uniffi_rgb_lib_fn_method_transportendpoint_transport_type(self.pointer, $0
    )
}
        )
    }
}

public struct FfiConverterTypeTransportEndpoint: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = TransportEndpoint

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransportEndpoint {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: TransportEndpoint, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> TransportEndpoint {
        return TransportEndpoint(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: TransportEndpoint) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeTransportEndpoint_lift(_ pointer: UnsafeMutableRawPointer) throws -> TransportEndpoint {
    return try FfiConverterTypeTransportEndpoint.lift(pointer)
}

public func FfiConverterTypeTransportEndpoint_lower(_ value: TransportEndpoint) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTransportEndpoint.lower(value)
}


public protocol WalletProtocol {
    func `backup`(`backupPath`: String, `password`: String)  throws
    func `backupInfo`()  throws -> Bool
    func `blindReceive`(`assetId`: String?, `amount`: UInt64?, `durationSeconds`: UInt32?, `transportEndpoints`: [String], `minConfirmations`: UInt8)  throws -> ReceiveData
    func `witnessReceive`(`assetId`: String?, `amount`: UInt64?, `durationSeconds`: UInt32?, `transportEndpoints`: [String], `minConfirmations`: UInt8)  throws -> ReceiveData
    func `signPsbt`(`unsignedPsbt`: String)  throws -> String
    func `createUtxos`(`online`: Online, `upTo`: Bool, `num`: UInt8?, `size`: UInt32?, `feeRate`: Float)  throws -> UInt8
    func `createUtxosBegin`(`online`: Online, `upTo`: Bool, `num`: UInt8?, `size`: UInt32?, `feeRate`: Float)  throws -> String
    func `createUtxosEnd`(`online`: Online, `signedPsbt`: String)  throws -> UInt8
    func `deleteTransfers`(`blindedUtxo`: String?, `txid`: String?, `noAssetOnly`: Bool)  throws -> Bool
    func `drainTo`(`online`: Online, `address`: String, `destroyAssets`: Bool, `feeRate`: Float)  throws -> String
    func `drainToBegin`(`online`: Online, `address`: String, `destroyAssets`: Bool, `feeRate`: Float)  throws -> String
    func `drainToEnd`(`online`: Online, `signedPsbt`: String)  throws -> String
    func `failTransfers`(`online`: Online, `blindedUtxo`: String?, `txid`: String?, `noAssetOnly`: Bool)  throws -> Bool
    func `getAddress`()  throws -> String
    func `getAssetBalance`(`assetId`: String)  throws -> Balance
    func `getBtcBalance`(`online`: Online)  throws -> BtcBalance
    func `getAssetMetadata`(`assetId`: String)  throws -> Metadata
    func `goOnline`(`skipConsistencyCheck`: Bool, `electrumUrl`: String)  throws -> Online
    func `issueAssetNia`(`online`: Online, `ticker`: String, `name`: String, `precision`: UInt8, `amounts`: [UInt64])  throws -> AssetNia
    func `issueAssetCfa`(`online`: Online, `name`: String, `description`: String?, `precision`: UInt8, `amounts`: [UInt64], `filePath`: String?)  throws -> AssetCfa
    func `listAssets`(`filterAssetSchemas`: [AssetSchema])  throws -> Assets
    func `listTransactions`(`online`: Online?)  throws -> [Transaction]
    func `listTransfers`(`assetId`: String?)  throws -> [Transfer]
    func `listUnspents`(`online`: Online?, `settledOnly`: Bool)  throws -> [Unspent]
    func `refresh`(`online`: Online, `assetId`: String?, `filter`: [RefreshFilter])  throws -> Bool
    func `send`(`online`: Online, `recipientMap`: [String: [Recipient]], `donation`: Bool, `feeRate`: Float, `minConfirmations`: UInt8)  throws -> String
    func `sendBegin`(`online`: Online, `recipientMap`: [String: [Recipient]], `donation`: Bool, `feeRate`: Float, `minConfirmations`: UInt8)  throws -> String
    func `sendEnd`(`online`: Online, `signedPsbt`: String)  throws -> String
    func `sendBtc`(`online`: Online, `address`: String, `amount`: UInt64, `feeRate`: Float)  throws -> String
    
}

public class Wallet: WalletProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`walletData`: WalletData) throws {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_constructor_wallet_new(
        FfiConverterTypeWalletData.lower(`walletData`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_rgb_lib_fn_free_wallet(pointer, $0) }
    }

    

    
    

    public func `backup`(`backupPath`: String, `password`: String) throws {
        try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_backup(self.pointer,
        FfiConverterString.lower(`backupPath`),
        FfiConverterString.lower(`password`),$0
    )
}
    }

    public func `backupInfo`() throws -> Bool {
        return try  FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_backup_info(self.pointer, $0
    )
}
        )
    }

    public func `blindReceive`(`assetId`: String?, `amount`: UInt64?, `durationSeconds`: UInt32?, `transportEndpoints`: [String], `minConfirmations`: UInt8) throws -> ReceiveData {
        return try  FfiConverterTypeReceiveData.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_blind_receive(self.pointer,
        FfiConverterOptionString.lower(`assetId`),
        FfiConverterOptionUInt64.lower(`amount`),
        FfiConverterOptionUInt32.lower(`durationSeconds`),
        FfiConverterSequenceString.lower(`transportEndpoints`),
        FfiConverterUInt8.lower(`minConfirmations`),$0
    )
}
        )
    }

    public func `witnessReceive`(`assetId`: String?, `amount`: UInt64?, `durationSeconds`: UInt32?, `transportEndpoints`: [String], `minConfirmations`: UInt8) throws -> ReceiveData {
        return try  FfiConverterTypeReceiveData.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_witness_receive(self.pointer,
        FfiConverterOptionString.lower(`assetId`),
        FfiConverterOptionUInt64.lower(`amount`),
        FfiConverterOptionUInt32.lower(`durationSeconds`),
        FfiConverterSequenceString.lower(`transportEndpoints`),
        FfiConverterUInt8.lower(`minConfirmations`),$0
    )
}
        )
    }

    public func `signPsbt`(`unsignedPsbt`: String) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_sign_psbt(self.pointer,
        FfiConverterString.lower(`unsignedPsbt`),$0
    )
}
        )
    }

    public func `createUtxos`(`online`: Online, `upTo`: Bool, `num`: UInt8?, `size`: UInt32?, `feeRate`: Float) throws -> UInt8 {
        return try  FfiConverterUInt8.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_create_utxos(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterBool.lower(`upTo`),
        FfiConverterOptionUInt8.lower(`num`),
        FfiConverterOptionUInt32.lower(`size`),
        FfiConverterFloat.lower(`feeRate`),$0
    )
}
        )
    }

    public func `createUtxosBegin`(`online`: Online, `upTo`: Bool, `num`: UInt8?, `size`: UInt32?, `feeRate`: Float) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_create_utxos_begin(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterBool.lower(`upTo`),
        FfiConverterOptionUInt8.lower(`num`),
        FfiConverterOptionUInt32.lower(`size`),
        FfiConverterFloat.lower(`feeRate`),$0
    )
}
        )
    }

    public func `createUtxosEnd`(`online`: Online, `signedPsbt`: String) throws -> UInt8 {
        return try  FfiConverterUInt8.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_create_utxos_end(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`signedPsbt`),$0
    )
}
        )
    }

    public func `deleteTransfers`(`blindedUtxo`: String?, `txid`: String?, `noAssetOnly`: Bool) throws -> Bool {
        return try  FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_delete_transfers(self.pointer,
        FfiConverterOptionString.lower(`blindedUtxo`),
        FfiConverterOptionString.lower(`txid`),
        FfiConverterBool.lower(`noAssetOnly`),$0
    )
}
        )
    }

    public func `drainTo`(`online`: Online, `address`: String, `destroyAssets`: Bool, `feeRate`: Float) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_drain_to(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`address`),
        FfiConverterBool.lower(`destroyAssets`),
        FfiConverterFloat.lower(`feeRate`),$0
    )
}
        )
    }

    public func `drainToBegin`(`online`: Online, `address`: String, `destroyAssets`: Bool, `feeRate`: Float) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_drain_to_begin(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`address`),
        FfiConverterBool.lower(`destroyAssets`),
        FfiConverterFloat.lower(`feeRate`),$0
    )
}
        )
    }

    public func `drainToEnd`(`online`: Online, `signedPsbt`: String) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_drain_to_end(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`signedPsbt`),$0
    )
}
        )
    }

    public func `failTransfers`(`online`: Online, `blindedUtxo`: String?, `txid`: String?, `noAssetOnly`: Bool) throws -> Bool {
        return try  FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_fail_transfers(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterOptionString.lower(`blindedUtxo`),
        FfiConverterOptionString.lower(`txid`),
        FfiConverterBool.lower(`noAssetOnly`),$0
    )
}
        )
    }

    public func `getAddress`() throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_get_address(self.pointer, $0
    )
}
        )
    }

    public func `getAssetBalance`(`assetId`: String) throws -> Balance {
        return try  FfiConverterTypeBalance.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_get_asset_balance(self.pointer,
        FfiConverterString.lower(`assetId`),$0
    )
}
        )
    }

    public func `getBtcBalance`(`online`: Online) throws -> BtcBalance {
        return try  FfiConverterTypeBtcBalance.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_get_btc_balance(self.pointer,
        FfiConverterTypeOnline.lower(`online`),$0
    )
}
        )
    }

    public func `getAssetMetadata`(`assetId`: String) throws -> Metadata {
        return try  FfiConverterTypeMetadata.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_get_asset_metadata(self.pointer,
        FfiConverterString.lower(`assetId`),$0
    )
}
        )
    }

    public func `goOnline`(`skipConsistencyCheck`: Bool, `electrumUrl`: String) throws -> Online {
        return try  FfiConverterTypeOnline.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_go_online(self.pointer,
        FfiConverterBool.lower(`skipConsistencyCheck`),
        FfiConverterString.lower(`electrumUrl`),$0
    )
}
        )
    }

    public func `issueAssetNia`(`online`: Online, `ticker`: String, `name`: String, `precision`: UInt8, `amounts`: [UInt64]) throws -> AssetNia {
        return try  FfiConverterTypeAssetNIA.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_issue_asset_nia(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`ticker`),
        FfiConverterString.lower(`name`),
        FfiConverterUInt8.lower(`precision`),
        FfiConverterSequenceUInt64.lower(`amounts`),$0
    )
}
        )
    }

    public func `issueAssetCfa`(`online`: Online, `name`: String, `description`: String?, `precision`: UInt8, `amounts`: [UInt64], `filePath`: String?) throws -> AssetCfa {
        return try  FfiConverterTypeAssetCFA.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_issue_asset_cfa(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`name`),
        FfiConverterOptionString.lower(`description`),
        FfiConverterUInt8.lower(`precision`),
        FfiConverterSequenceUInt64.lower(`amounts`),
        FfiConverterOptionString.lower(`filePath`),$0
    )
}
        )
    }

    public func `listAssets`(`filterAssetSchemas`: [AssetSchema]) throws -> Assets {
        return try  FfiConverterTypeAssets.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_list_assets(self.pointer,
        FfiConverterSequenceTypeAssetSchema.lower(`filterAssetSchemas`),$0
    )
}
        )
    }

    public func `listTransactions`(`online`: Online?) throws -> [Transaction] {
        return try  FfiConverterSequenceTypeTransaction.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_list_transactions(self.pointer,
        FfiConverterOptionTypeOnline.lower(`online`),$0
    )
}
        )
    }

    public func `listTransfers`(`assetId`: String?) throws -> [Transfer] {
        return try  FfiConverterSequenceTypeTransfer.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_list_transfers(self.pointer,
        FfiConverterOptionString.lower(`assetId`),$0
    )
}
        )
    }

    public func `listUnspents`(`online`: Online?, `settledOnly`: Bool) throws -> [Unspent] {
        return try  FfiConverterSequenceTypeUnspent.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_list_unspents(self.pointer,
        FfiConverterOptionTypeOnline.lower(`online`),
        FfiConverterBool.lower(`settledOnly`),$0
    )
}
        )
    }

    public func `refresh`(`online`: Online, `assetId`: String?, `filter`: [RefreshFilter]) throws -> Bool {
        return try  FfiConverterBool.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_refresh(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterOptionString.lower(`assetId`),
        FfiConverterSequenceTypeRefreshFilter.lower(`filter`),$0
    )
}
        )
    }

    public func `send`(`online`: Online, `recipientMap`: [String: [Recipient]], `donation`: Bool, `feeRate`: Float, `minConfirmations`: UInt8) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_send(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterDictionaryStringSequenceTypeRecipient.lower(`recipientMap`),
        FfiConverterBool.lower(`donation`),
        FfiConverterFloat.lower(`feeRate`),
        FfiConverterUInt8.lower(`minConfirmations`),$0
    )
}
        )
    }

    public func `sendBegin`(`online`: Online, `recipientMap`: [String: [Recipient]], `donation`: Bool, `feeRate`: Float, `minConfirmations`: UInt8) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_send_begin(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterDictionaryStringSequenceTypeRecipient.lower(`recipientMap`),
        FfiConverterBool.lower(`donation`),
        FfiConverterFloat.lower(`feeRate`),
        FfiConverterUInt8.lower(`minConfirmations`),$0
    )
}
        )
    }

    public func `sendEnd`(`online`: Online, `signedPsbt`: String) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_send_end(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`signedPsbt`),$0
    )
}
        )
    }

    public func `sendBtc`(`online`: Online, `address`: String, `amount`: UInt64, `feeRate`: Float) throws -> String {
        return try  FfiConverterString.lift(
            try
    rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_method_wallet_send_btc(self.pointer,
        FfiConverterTypeOnline.lower(`online`),
        FfiConverterString.lower(`address`),
        FfiConverterUInt64.lower(`amount`),
        FfiConverterFloat.lower(`feeRate`),$0
    )
}
        )
    }
}

public struct FfiConverterTypeWallet: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Wallet

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Wallet {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Wallet, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
        return Wallet(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Wallet) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeWallet_lift(_ pointer: UnsafeMutableRawPointer) throws -> Wallet {
    return try FfiConverterTypeWallet.lift(pointer)
}

public func FfiConverterTypeWallet_lower(_ value: Wallet) -> UnsafeMutableRawPointer {
    return FfiConverterTypeWallet.lower(value)
}


public struct AssetCfa {
    public var `assetId`: String
    public var `assetIface`: AssetIface
    public var `name`: String
    public var `description`: String?
    public var `precision`: UInt8
    public var `issuedSupply`: UInt64
    public var `timestamp`: Int64
    public var `addedAt`: Int64
    public var `balance`: Balance
    public var `dataPaths`: [Media]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`assetId`: String, `assetIface`: AssetIface, `name`: String, `description`: String?, `precision`: UInt8, `issuedSupply`: UInt64, `timestamp`: Int64, `addedAt`: Int64, `balance`: Balance, `dataPaths`: [Media]) {
        self.`assetId` = `assetId`
        self.`assetIface` = `assetIface`
        self.`name` = `name`
        self.`description` = `description`
        self.`precision` = `precision`
        self.`issuedSupply` = `issuedSupply`
        self.`timestamp` = `timestamp`
        self.`addedAt` = `addedAt`
        self.`balance` = `balance`
        self.`dataPaths` = `dataPaths`
    }
}


extension AssetCfa: Equatable, Hashable {
    public static func ==(lhs: AssetCfa, rhs: AssetCfa) -> Bool {
        if lhs.`assetId` != rhs.`assetId` {
            return false
        }
        if lhs.`assetIface` != rhs.`assetIface` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        if lhs.`precision` != rhs.`precision` {
            return false
        }
        if lhs.`issuedSupply` != rhs.`issuedSupply` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`addedAt` != rhs.`addedAt` {
            return false
        }
        if lhs.`balance` != rhs.`balance` {
            return false
        }
        if lhs.`dataPaths` != rhs.`dataPaths` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`assetId`)
        hasher.combine(`assetIface`)
        hasher.combine(`name`)
        hasher.combine(`description`)
        hasher.combine(`precision`)
        hasher.combine(`issuedSupply`)
        hasher.combine(`timestamp`)
        hasher.combine(`addedAt`)
        hasher.combine(`balance`)
        hasher.combine(`dataPaths`)
    }
}


public struct FfiConverterTypeAssetCFA: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetCfa {
        return try AssetCfa(
            `assetId`: FfiConverterString.read(from: &buf),
            `assetIface`: FfiConverterTypeAssetIface.read(from: &buf),
            `name`: FfiConverterString.read(from: &buf),
            `description`: FfiConverterOptionString.read(from: &buf),
            `precision`: FfiConverterUInt8.read(from: &buf),
            `issuedSupply`: FfiConverterUInt64.read(from: &buf),
            `timestamp`: FfiConverterInt64.read(from: &buf),
            `addedAt`: FfiConverterInt64.read(from: &buf),
            `balance`: FfiConverterTypeBalance.read(from: &buf),
            `dataPaths`: FfiConverterSequenceTypeMedia.read(from: &buf)
        )
    }

    public static func write(_ value: AssetCfa, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`assetId`, into: &buf)
        FfiConverterTypeAssetIface.write(value.`assetIface`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterOptionString.write(value.`description`, into: &buf)
        FfiConverterUInt8.write(value.`precision`, into: &buf)
        FfiConverterUInt64.write(value.`issuedSupply`, into: &buf)
        FfiConverterInt64.write(value.`timestamp`, into: &buf)
        FfiConverterInt64.write(value.`addedAt`, into: &buf)
        FfiConverterTypeBalance.write(value.`balance`, into: &buf)
        FfiConverterSequenceTypeMedia.write(value.`dataPaths`, into: &buf)
    }
}


public func FfiConverterTypeAssetCFA_lift(_ buf: RustBuffer) throws -> AssetCfa {
    return try FfiConverterTypeAssetCFA.lift(buf)
}

public func FfiConverterTypeAssetCFA_lower(_ value: AssetCfa) -> RustBuffer {
    return FfiConverterTypeAssetCFA.lower(value)
}


public struct AssetNia {
    public var `assetId`: String
    public var `assetIface`: AssetIface
    public var `ticker`: String
    public var `name`: String
    public var `precision`: UInt8
    public var `issuedSupply`: UInt64
    public var `timestamp`: Int64
    public var `addedAt`: Int64
    public var `balance`: Balance
    public var `dataPaths`: [Media]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`assetId`: String, `assetIface`: AssetIface, `ticker`: String, `name`: String, `precision`: UInt8, `issuedSupply`: UInt64, `timestamp`: Int64, `addedAt`: Int64, `balance`: Balance, `dataPaths`: [Media]) {
        self.`assetId` = `assetId`
        self.`assetIface` = `assetIface`
        self.`ticker` = `ticker`
        self.`name` = `name`
        self.`precision` = `precision`
        self.`issuedSupply` = `issuedSupply`
        self.`timestamp` = `timestamp`
        self.`addedAt` = `addedAt`
        self.`balance` = `balance`
        self.`dataPaths` = `dataPaths`
    }
}


extension AssetNia: Equatable, Hashable {
    public static func ==(lhs: AssetNia, rhs: AssetNia) -> Bool {
        if lhs.`assetId` != rhs.`assetId` {
            return false
        }
        if lhs.`assetIface` != rhs.`assetIface` {
            return false
        }
        if lhs.`ticker` != rhs.`ticker` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`precision` != rhs.`precision` {
            return false
        }
        if lhs.`issuedSupply` != rhs.`issuedSupply` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`addedAt` != rhs.`addedAt` {
            return false
        }
        if lhs.`balance` != rhs.`balance` {
            return false
        }
        if lhs.`dataPaths` != rhs.`dataPaths` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`assetId`)
        hasher.combine(`assetIface`)
        hasher.combine(`ticker`)
        hasher.combine(`name`)
        hasher.combine(`precision`)
        hasher.combine(`issuedSupply`)
        hasher.combine(`timestamp`)
        hasher.combine(`addedAt`)
        hasher.combine(`balance`)
        hasher.combine(`dataPaths`)
    }
}


public struct FfiConverterTypeAssetNIA: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetNia {
        return try AssetNia(
            `assetId`: FfiConverterString.read(from: &buf),
            `assetIface`: FfiConverterTypeAssetIface.read(from: &buf),
            `ticker`: FfiConverterString.read(from: &buf),
            `name`: FfiConverterString.read(from: &buf),
            `precision`: FfiConverterUInt8.read(from: &buf),
            `issuedSupply`: FfiConverterUInt64.read(from: &buf),
            `timestamp`: FfiConverterInt64.read(from: &buf),
            `addedAt`: FfiConverterInt64.read(from: &buf),
            `balance`: FfiConverterTypeBalance.read(from: &buf),
            `dataPaths`: FfiConverterSequenceTypeMedia.read(from: &buf)
        )
    }

    public static func write(_ value: AssetNia, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`assetId`, into: &buf)
        FfiConverterTypeAssetIface.write(value.`assetIface`, into: &buf)
        FfiConverterString.write(value.`ticker`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterUInt8.write(value.`precision`, into: &buf)
        FfiConverterUInt64.write(value.`issuedSupply`, into: &buf)
        FfiConverterInt64.write(value.`timestamp`, into: &buf)
        FfiConverterInt64.write(value.`addedAt`, into: &buf)
        FfiConverterTypeBalance.write(value.`balance`, into: &buf)
        FfiConverterSequenceTypeMedia.write(value.`dataPaths`, into: &buf)
    }
}


public func FfiConverterTypeAssetNIA_lift(_ buf: RustBuffer) throws -> AssetNia {
    return try FfiConverterTypeAssetNIA.lift(buf)
}

public func FfiConverterTypeAssetNIA_lower(_ value: AssetNia) -> RustBuffer {
    return FfiConverterTypeAssetNIA.lower(value)
}


public struct Assets {
    public var `nia`: [AssetNia]?
    public var `cfa`: [AssetCfa]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`nia`: [AssetNia]?, `cfa`: [AssetCfa]?) {
        self.`nia` = `nia`
        self.`cfa` = `cfa`
    }
}


extension Assets: Equatable, Hashable {
    public static func ==(lhs: Assets, rhs: Assets) -> Bool {
        if lhs.`nia` != rhs.`nia` {
            return false
        }
        if lhs.`cfa` != rhs.`cfa` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`nia`)
        hasher.combine(`cfa`)
    }
}


public struct FfiConverterTypeAssets: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Assets {
        return try Assets(
            `nia`: FfiConverterOptionSequenceTypeAssetNIA.read(from: &buf),
            `cfa`: FfiConverterOptionSequenceTypeAssetCFA.read(from: &buf)
        )
    }

    public static func write(_ value: Assets, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeAssetNIA.write(value.`nia`, into: &buf)
        FfiConverterOptionSequenceTypeAssetCFA.write(value.`cfa`, into: &buf)
    }
}


public func FfiConverterTypeAssets_lift(_ buf: RustBuffer) throws -> Assets {
    return try FfiConverterTypeAssets.lift(buf)
}

public func FfiConverterTypeAssets_lower(_ value: Assets) -> RustBuffer {
    return FfiConverterTypeAssets.lower(value)
}


public struct Balance {
    public var `settled`: UInt64
    public var `future`: UInt64
    public var `spendable`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`settled`: UInt64, `future`: UInt64, `spendable`: UInt64) {
        self.`settled` = `settled`
        self.`future` = `future`
        self.`spendable` = `spendable`
    }
}


extension Balance: Equatable, Hashable {
    public static func ==(lhs: Balance, rhs: Balance) -> Bool {
        if lhs.`settled` != rhs.`settled` {
            return false
        }
        if lhs.`future` != rhs.`future` {
            return false
        }
        if lhs.`spendable` != rhs.`spendable` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`settled`)
        hasher.combine(`future`)
        hasher.combine(`spendable`)
    }
}


public struct FfiConverterTypeBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Balance {
        return try Balance(
            `settled`: FfiConverterUInt64.read(from: &buf),
            `future`: FfiConverterUInt64.read(from: &buf),
            `spendable`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Balance, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`settled`, into: &buf)
        FfiConverterUInt64.write(value.`future`, into: &buf)
        FfiConverterUInt64.write(value.`spendable`, into: &buf)
    }
}


public func FfiConverterTypeBalance_lift(_ buf: RustBuffer) throws -> Balance {
    return try FfiConverterTypeBalance.lift(buf)
}

public func FfiConverterTypeBalance_lower(_ value: Balance) -> RustBuffer {
    return FfiConverterTypeBalance.lower(value)
}


public struct BlockTime {
    public var `height`: UInt32
    public var `timestamp`: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`height`: UInt32, `timestamp`: UInt64) {
        self.`height` = `height`
        self.`timestamp` = `timestamp`
    }
}


extension BlockTime: Equatable, Hashable {
    public static func ==(lhs: BlockTime, rhs: BlockTime) -> Bool {
        if lhs.`height` != rhs.`height` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`height`)
        hasher.combine(`timestamp`)
    }
}


public struct FfiConverterTypeBlockTime: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BlockTime {
        return try BlockTime(
            `height`: FfiConverterUInt32.read(from: &buf),
            `timestamp`: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: BlockTime, into buf: inout [UInt8]) {
        FfiConverterUInt32.write(value.`height`, into: &buf)
        FfiConverterUInt64.write(value.`timestamp`, into: &buf)
    }
}


public func FfiConverterTypeBlockTime_lift(_ buf: RustBuffer) throws -> BlockTime {
    return try FfiConverterTypeBlockTime.lift(buf)
}

public func FfiConverterTypeBlockTime_lower(_ value: BlockTime) -> RustBuffer {
    return FfiConverterTypeBlockTime.lower(value)
}


public struct BtcBalance {
    public var `vanilla`: Balance
    public var `colored`: Balance

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`vanilla`: Balance, `colored`: Balance) {
        self.`vanilla` = `vanilla`
        self.`colored` = `colored`
    }
}


extension BtcBalance: Equatable, Hashable {
    public static func ==(lhs: BtcBalance, rhs: BtcBalance) -> Bool {
        if lhs.`vanilla` != rhs.`vanilla` {
            return false
        }
        if lhs.`colored` != rhs.`colored` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`vanilla`)
        hasher.combine(`colored`)
    }
}


public struct FfiConverterTypeBtcBalance: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BtcBalance {
        return try BtcBalance(
            `vanilla`: FfiConverterTypeBalance.read(from: &buf),
            `colored`: FfiConverterTypeBalance.read(from: &buf)
        )
    }

    public static func write(_ value: BtcBalance, into buf: inout [UInt8]) {
        FfiConverterTypeBalance.write(value.`vanilla`, into: &buf)
        FfiConverterTypeBalance.write(value.`colored`, into: &buf)
    }
}


public func FfiConverterTypeBtcBalance_lift(_ buf: RustBuffer) throws -> BtcBalance {
    return try FfiConverterTypeBtcBalance.lift(buf)
}

public func FfiConverterTypeBtcBalance_lower(_ value: BtcBalance) -> RustBuffer {
    return FfiConverterTypeBtcBalance.lower(value)
}


public struct InvoiceData {
    public var `recipientId`: String
    public var `assetIface`: AssetIface?
    public var `assetId`: String?
    public var `amount`: UInt64?
    public var `network`: BitcoinNetwork?
    public var `expirationTimestamp`: Int64?
    public var `transportEndpoints`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`recipientId`: String, `assetIface`: AssetIface?, `assetId`: String?, `amount`: UInt64?, `network`: BitcoinNetwork?, `expirationTimestamp`: Int64?, `transportEndpoints`: [String]) {
        self.`recipientId` = `recipientId`
        self.`assetIface` = `assetIface`
        self.`assetId` = `assetId`
        self.`amount` = `amount`
        self.`network` = `network`
        self.`expirationTimestamp` = `expirationTimestamp`
        self.`transportEndpoints` = `transportEndpoints`
    }
}


extension InvoiceData: Equatable, Hashable {
    public static func ==(lhs: InvoiceData, rhs: InvoiceData) -> Bool {
        if lhs.`recipientId` != rhs.`recipientId` {
            return false
        }
        if lhs.`assetIface` != rhs.`assetIface` {
            return false
        }
        if lhs.`assetId` != rhs.`assetId` {
            return false
        }
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`network` != rhs.`network` {
            return false
        }
        if lhs.`expirationTimestamp` != rhs.`expirationTimestamp` {
            return false
        }
        if lhs.`transportEndpoints` != rhs.`transportEndpoints` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`recipientId`)
        hasher.combine(`assetIface`)
        hasher.combine(`assetId`)
        hasher.combine(`amount`)
        hasher.combine(`network`)
        hasher.combine(`expirationTimestamp`)
        hasher.combine(`transportEndpoints`)
    }
}


public struct FfiConverterTypeInvoiceData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InvoiceData {
        return try InvoiceData(
            `recipientId`: FfiConverterString.read(from: &buf),
            `assetIface`: FfiConverterOptionTypeAssetIface.read(from: &buf),
            `assetId`: FfiConverterOptionString.read(from: &buf),
            `amount`: FfiConverterOptionUInt64.read(from: &buf),
            `network`: FfiConverterOptionTypeBitcoinNetwork.read(from: &buf),
            `expirationTimestamp`: FfiConverterOptionInt64.read(from: &buf),
            `transportEndpoints`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: InvoiceData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`recipientId`, into: &buf)
        FfiConverterOptionTypeAssetIface.write(value.`assetIface`, into: &buf)
        FfiConverterOptionString.write(value.`assetId`, into: &buf)
        FfiConverterOptionUInt64.write(value.`amount`, into: &buf)
        FfiConverterOptionTypeBitcoinNetwork.write(value.`network`, into: &buf)
        FfiConverterOptionInt64.write(value.`expirationTimestamp`, into: &buf)
        FfiConverterSequenceString.write(value.`transportEndpoints`, into: &buf)
    }
}


public func FfiConverterTypeInvoiceData_lift(_ buf: RustBuffer) throws -> InvoiceData {
    return try FfiConverterTypeInvoiceData.lift(buf)
}

public func FfiConverterTypeInvoiceData_lower(_ value: InvoiceData) -> RustBuffer {
    return FfiConverterTypeInvoiceData.lower(value)
}


public struct Keys {
    public var `mnemonic`: String
    public var `xpub`: String
    public var `xpubFingerprint`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`mnemonic`: String, `xpub`: String, `xpubFingerprint`: String) {
        self.`mnemonic` = `mnemonic`
        self.`xpub` = `xpub`
        self.`xpubFingerprint` = `xpubFingerprint`
    }
}


extension Keys: Equatable, Hashable {
    public static func ==(lhs: Keys, rhs: Keys) -> Bool {
        if lhs.`mnemonic` != rhs.`mnemonic` {
            return false
        }
        if lhs.`xpub` != rhs.`xpub` {
            return false
        }
        if lhs.`xpubFingerprint` != rhs.`xpubFingerprint` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`mnemonic`)
        hasher.combine(`xpub`)
        hasher.combine(`xpubFingerprint`)
    }
}


public struct FfiConverterTypeKeys: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keys {
        return try Keys(
            `mnemonic`: FfiConverterString.read(from: &buf),
            `xpub`: FfiConverterString.read(from: &buf),
            `xpubFingerprint`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Keys, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`mnemonic`, into: &buf)
        FfiConverterString.write(value.`xpub`, into: &buf)
        FfiConverterString.write(value.`xpubFingerprint`, into: &buf)
    }
}


public func FfiConverterTypeKeys_lift(_ buf: RustBuffer) throws -> Keys {
    return try FfiConverterTypeKeys.lift(buf)
}

public func FfiConverterTypeKeys_lower(_ value: Keys) -> RustBuffer {
    return FfiConverterTypeKeys.lower(value)
}


public struct Media {
    public var `filePath`: String
    public var `mime`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`filePath`: String, `mime`: String) {
        self.`filePath` = `filePath`
        self.`mime` = `mime`
    }
}


extension Media: Equatable, Hashable {
    public static func ==(lhs: Media, rhs: Media) -> Bool {
        if lhs.`filePath` != rhs.`filePath` {
            return false
        }
        if lhs.`mime` != rhs.`mime` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`filePath`)
        hasher.combine(`mime`)
    }
}


public struct FfiConverterTypeMedia: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Media {
        return try Media(
            `filePath`: FfiConverterString.read(from: &buf),
            `mime`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Media, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`filePath`, into: &buf)
        FfiConverterString.write(value.`mime`, into: &buf)
    }
}


public func FfiConverterTypeMedia_lift(_ buf: RustBuffer) throws -> Media {
    return try FfiConverterTypeMedia.lift(buf)
}

public func FfiConverterTypeMedia_lower(_ value: Media) -> RustBuffer {
    return FfiConverterTypeMedia.lower(value)
}


public struct Metadata {
    public var `assetIface`: AssetIface
    public var `assetSchema`: AssetSchema
    public var `issuedSupply`: UInt64
    public var `timestamp`: Int64
    public var `name`: String
    public var `precision`: UInt8
    public var `ticker`: String?
    public var `description`: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`assetIface`: AssetIface, `assetSchema`: AssetSchema, `issuedSupply`: UInt64, `timestamp`: Int64, `name`: String, `precision`: UInt8, `ticker`: String?, `description`: String?) {
        self.`assetIface` = `assetIface`
        self.`assetSchema` = `assetSchema`
        self.`issuedSupply` = `issuedSupply`
        self.`timestamp` = `timestamp`
        self.`name` = `name`
        self.`precision` = `precision`
        self.`ticker` = `ticker`
        self.`description` = `description`
    }
}


extension Metadata: Equatable, Hashable {
    public static func ==(lhs: Metadata, rhs: Metadata) -> Bool {
        if lhs.`assetIface` != rhs.`assetIface` {
            return false
        }
        if lhs.`assetSchema` != rhs.`assetSchema` {
            return false
        }
        if lhs.`issuedSupply` != rhs.`issuedSupply` {
            return false
        }
        if lhs.`timestamp` != rhs.`timestamp` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`precision` != rhs.`precision` {
            return false
        }
        if lhs.`ticker` != rhs.`ticker` {
            return false
        }
        if lhs.`description` != rhs.`description` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`assetIface`)
        hasher.combine(`assetSchema`)
        hasher.combine(`issuedSupply`)
        hasher.combine(`timestamp`)
        hasher.combine(`name`)
        hasher.combine(`precision`)
        hasher.combine(`ticker`)
        hasher.combine(`description`)
    }
}


public struct FfiConverterTypeMetadata: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Metadata {
        return try Metadata(
            `assetIface`: FfiConverterTypeAssetIface.read(from: &buf),
            `assetSchema`: FfiConverterTypeAssetSchema.read(from: &buf),
            `issuedSupply`: FfiConverterUInt64.read(from: &buf),
            `timestamp`: FfiConverterInt64.read(from: &buf),
            `name`: FfiConverterString.read(from: &buf),
            `precision`: FfiConverterUInt8.read(from: &buf),
            `ticker`: FfiConverterOptionString.read(from: &buf),
            `description`: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Metadata, into buf: inout [UInt8]) {
        FfiConverterTypeAssetIface.write(value.`assetIface`, into: &buf)
        FfiConverterTypeAssetSchema.write(value.`assetSchema`, into: &buf)
        FfiConverterUInt64.write(value.`issuedSupply`, into: &buf)
        FfiConverterInt64.write(value.`timestamp`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterUInt8.write(value.`precision`, into: &buf)
        FfiConverterOptionString.write(value.`ticker`, into: &buf)
        FfiConverterOptionString.write(value.`description`, into: &buf)
    }
}


public func FfiConverterTypeMetadata_lift(_ buf: RustBuffer) throws -> Metadata {
    return try FfiConverterTypeMetadata.lift(buf)
}

public func FfiConverterTypeMetadata_lower(_ value: Metadata) -> RustBuffer {
    return FfiConverterTypeMetadata.lower(value)
}


public struct Online {
    public var `id`: UInt64
    public var `electrumUrl`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: UInt64, `electrumUrl`: String) {
        self.`id` = `id`
        self.`electrumUrl` = `electrumUrl`
    }
}


extension Online: Equatable, Hashable {
    public static func ==(lhs: Online, rhs: Online) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`electrumUrl` != rhs.`electrumUrl` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`electrumUrl`)
    }
}


public struct FfiConverterTypeOnline: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Online {
        return try Online(
            `id`: FfiConverterUInt64.read(from: &buf),
            `electrumUrl`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Online, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`electrumUrl`, into: &buf)
    }
}


public func FfiConverterTypeOnline_lift(_ buf: RustBuffer) throws -> Online {
    return try FfiConverterTypeOnline.lift(buf)
}

public func FfiConverterTypeOnline_lower(_ value: Online) -> RustBuffer {
    return FfiConverterTypeOnline.lower(value)
}


public struct Outpoint {
    public var `txid`: String
    public var `vout`: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`txid`: String, `vout`: UInt32) {
        self.`txid` = `txid`
        self.`vout` = `vout`
    }
}


extension Outpoint: Equatable, Hashable {
    public static func ==(lhs: Outpoint, rhs: Outpoint) -> Bool {
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        if lhs.`vout` != rhs.`vout` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`txid`)
        hasher.combine(`vout`)
    }
}


public struct FfiConverterTypeOutpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Outpoint {
        return try Outpoint(
            `txid`: FfiConverterString.read(from: &buf),
            `vout`: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: Outpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`txid`, into: &buf)
        FfiConverterUInt32.write(value.`vout`, into: &buf)
    }
}


public func FfiConverterTypeOutpoint_lift(_ buf: RustBuffer) throws -> Outpoint {
    return try FfiConverterTypeOutpoint.lift(buf)
}

public func FfiConverterTypeOutpoint_lower(_ value: Outpoint) -> RustBuffer {
    return FfiConverterTypeOutpoint.lower(value)
}


public struct ReceiveData {
    public var `invoice`: String
    public var `recipientId`: String
    public var `expirationTimestamp`: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`invoice`: String, `recipientId`: String, `expirationTimestamp`: Int64?) {
        self.`invoice` = `invoice`
        self.`recipientId` = `recipientId`
        self.`expirationTimestamp` = `expirationTimestamp`
    }
}


extension ReceiveData: Equatable, Hashable {
    public static func ==(lhs: ReceiveData, rhs: ReceiveData) -> Bool {
        if lhs.`invoice` != rhs.`invoice` {
            return false
        }
        if lhs.`recipientId` != rhs.`recipientId` {
            return false
        }
        if lhs.`expirationTimestamp` != rhs.`expirationTimestamp` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`invoice`)
        hasher.combine(`recipientId`)
        hasher.combine(`expirationTimestamp`)
    }
}


public struct FfiConverterTypeReceiveData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiveData {
        return try ReceiveData(
            `invoice`: FfiConverterString.read(from: &buf),
            `recipientId`: FfiConverterString.read(from: &buf),
            `expirationTimestamp`: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ReceiveData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`invoice`, into: &buf)
        FfiConverterString.write(value.`recipientId`, into: &buf)
        FfiConverterOptionInt64.write(value.`expirationTimestamp`, into: &buf)
    }
}


public func FfiConverterTypeReceiveData_lift(_ buf: RustBuffer) throws -> ReceiveData {
    return try FfiConverterTypeReceiveData.lift(buf)
}

public func FfiConverterTypeReceiveData_lower(_ value: ReceiveData) -> RustBuffer {
    return FfiConverterTypeReceiveData.lower(value)
}


public struct Recipient {
    public var `blindedUtxo`: String?
    public var `scriptData`: ScriptData?
    public var `amount`: UInt64
    public var `transportEndpoints`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`blindedUtxo`: String?, `scriptData`: ScriptData?, `amount`: UInt64, `transportEndpoints`: [String]) {
        self.`blindedUtxo` = `blindedUtxo`
        self.`scriptData` = `scriptData`
        self.`amount` = `amount`
        self.`transportEndpoints` = `transportEndpoints`
    }
}


extension Recipient: Equatable, Hashable {
    public static func ==(lhs: Recipient, rhs: Recipient) -> Bool {
        if lhs.`blindedUtxo` != rhs.`blindedUtxo` {
            return false
        }
        if lhs.`scriptData` != rhs.`scriptData` {
            return false
        }
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`transportEndpoints` != rhs.`transportEndpoints` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`blindedUtxo`)
        hasher.combine(`scriptData`)
        hasher.combine(`amount`)
        hasher.combine(`transportEndpoints`)
    }
}


public struct FfiConverterTypeRecipient: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Recipient {
        return try Recipient(
            `blindedUtxo`: FfiConverterOptionString.read(from: &buf),
            `scriptData`: FfiConverterOptionTypeScriptData.read(from: &buf),
            `amount`: FfiConverterUInt64.read(from: &buf),
            `transportEndpoints`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: Recipient, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`blindedUtxo`, into: &buf)
        FfiConverterOptionTypeScriptData.write(value.`scriptData`, into: &buf)
        FfiConverterUInt64.write(value.`amount`, into: &buf)
        FfiConverterSequenceString.write(value.`transportEndpoints`, into: &buf)
    }
}


public func FfiConverterTypeRecipient_lift(_ buf: RustBuffer) throws -> Recipient {
    return try FfiConverterTypeRecipient.lift(buf)
}

public func FfiConverterTypeRecipient_lower(_ value: Recipient) -> RustBuffer {
    return FfiConverterTypeRecipient.lower(value)
}


public struct RefreshFilter {
    public var `status`: RefreshTransferStatus
    public var `incoming`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`status`: RefreshTransferStatus, `incoming`: Bool) {
        self.`status` = `status`
        self.`incoming` = `incoming`
    }
}


extension RefreshFilter: Equatable, Hashable {
    public static func ==(lhs: RefreshFilter, rhs: RefreshFilter) -> Bool {
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`incoming` != rhs.`incoming` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`status`)
        hasher.combine(`incoming`)
    }
}


public struct FfiConverterTypeRefreshFilter: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefreshFilter {
        return try RefreshFilter(
            `status`: FfiConverterTypeRefreshTransferStatus.read(from: &buf),
            `incoming`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RefreshFilter, into buf: inout [UInt8]) {
        FfiConverterTypeRefreshTransferStatus.write(value.`status`, into: &buf)
        FfiConverterBool.write(value.`incoming`, into: &buf)
    }
}


public func FfiConverterTypeRefreshFilter_lift(_ buf: RustBuffer) throws -> RefreshFilter {
    return try FfiConverterTypeRefreshFilter.lift(buf)
}

public func FfiConverterTypeRefreshFilter_lower(_ value: RefreshFilter) -> RustBuffer {
    return FfiConverterTypeRefreshFilter.lower(value)
}


public struct RgbAllocation {
    public var `assetId`: String?
    public var `amount`: UInt64
    public var `settled`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`assetId`: String?, `amount`: UInt64, `settled`: Bool) {
        self.`assetId` = `assetId`
        self.`amount` = `amount`
        self.`settled` = `settled`
    }
}


extension RgbAllocation: Equatable, Hashable {
    public static func ==(lhs: RgbAllocation, rhs: RgbAllocation) -> Bool {
        if lhs.`assetId` != rhs.`assetId` {
            return false
        }
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`settled` != rhs.`settled` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`assetId`)
        hasher.combine(`amount`)
        hasher.combine(`settled`)
    }
}


public struct FfiConverterTypeRgbAllocation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RgbAllocation {
        return try RgbAllocation(
            `assetId`: FfiConverterOptionString.read(from: &buf),
            `amount`: FfiConverterUInt64.read(from: &buf),
            `settled`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RgbAllocation, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.`assetId`, into: &buf)
        FfiConverterUInt64.write(value.`amount`, into: &buf)
        FfiConverterBool.write(value.`settled`, into: &buf)
    }
}


public func FfiConverterTypeRgbAllocation_lift(_ buf: RustBuffer) throws -> RgbAllocation {
    return try FfiConverterTypeRgbAllocation.lift(buf)
}

public func FfiConverterTypeRgbAllocation_lower(_ value: RgbAllocation) -> RustBuffer {
    return FfiConverterTypeRgbAllocation.lower(value)
}


public struct ScriptData {
    public var `script`: String
    public var `amountSat`: UInt64
    public var `blinding`: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`script`: String, `amountSat`: UInt64, `blinding`: UInt64?) {
        self.`script` = `script`
        self.`amountSat` = `amountSat`
        self.`blinding` = `blinding`
    }
}


extension ScriptData: Equatable, Hashable {
    public static func ==(lhs: ScriptData, rhs: ScriptData) -> Bool {
        if lhs.`script` != rhs.`script` {
            return false
        }
        if lhs.`amountSat` != rhs.`amountSat` {
            return false
        }
        if lhs.`blinding` != rhs.`blinding` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`script`)
        hasher.combine(`amountSat`)
        hasher.combine(`blinding`)
    }
}


public struct FfiConverterTypeScriptData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ScriptData {
        return try ScriptData(
            `script`: FfiConverterString.read(from: &buf),
            `amountSat`: FfiConverterUInt64.read(from: &buf),
            `blinding`: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ScriptData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`script`, into: &buf)
        FfiConverterUInt64.write(value.`amountSat`, into: &buf)
        FfiConverterOptionUInt64.write(value.`blinding`, into: &buf)
    }
}


public func FfiConverterTypeScriptData_lift(_ buf: RustBuffer) throws -> ScriptData {
    return try FfiConverterTypeScriptData.lift(buf)
}

public func FfiConverterTypeScriptData_lower(_ value: ScriptData) -> RustBuffer {
    return FfiConverterTypeScriptData.lower(value)
}


public struct Transaction {
    public var `transactionType`: TransactionType
    public var `txid`: String
    public var `received`: UInt64
    public var `sent`: UInt64
    public var `fee`: UInt64?
    public var `confirmationTime`: BlockTime?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`transactionType`: TransactionType, `txid`: String, `received`: UInt64, `sent`: UInt64, `fee`: UInt64?, `confirmationTime`: BlockTime?) {
        self.`transactionType` = `transactionType`
        self.`txid` = `txid`
        self.`received` = `received`
        self.`sent` = `sent`
        self.`fee` = `fee`
        self.`confirmationTime` = `confirmationTime`
    }
}


extension Transaction: Equatable, Hashable {
    public static func ==(lhs: Transaction, rhs: Transaction) -> Bool {
        if lhs.`transactionType` != rhs.`transactionType` {
            return false
        }
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        if lhs.`received` != rhs.`received` {
            return false
        }
        if lhs.`sent` != rhs.`sent` {
            return false
        }
        if lhs.`fee` != rhs.`fee` {
            return false
        }
        if lhs.`confirmationTime` != rhs.`confirmationTime` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`transactionType`)
        hasher.combine(`txid`)
        hasher.combine(`received`)
        hasher.combine(`sent`)
        hasher.combine(`fee`)
        hasher.combine(`confirmationTime`)
    }
}


public struct FfiConverterTypeTransaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transaction {
        return try Transaction(
            `transactionType`: FfiConverterTypeTransactionType.read(from: &buf),
            `txid`: FfiConverterString.read(from: &buf),
            `received`: FfiConverterUInt64.read(from: &buf),
            `sent`: FfiConverterUInt64.read(from: &buf),
            `fee`: FfiConverterOptionUInt64.read(from: &buf),
            `confirmationTime`: FfiConverterOptionTypeBlockTime.read(from: &buf)
        )
    }

    public static func write(_ value: Transaction, into buf: inout [UInt8]) {
        FfiConverterTypeTransactionType.write(value.`transactionType`, into: &buf)
        FfiConverterString.write(value.`txid`, into: &buf)
        FfiConverterUInt64.write(value.`received`, into: &buf)
        FfiConverterUInt64.write(value.`sent`, into: &buf)
        FfiConverterOptionUInt64.write(value.`fee`, into: &buf)
        FfiConverterOptionTypeBlockTime.write(value.`confirmationTime`, into: &buf)
    }
}


public func FfiConverterTypeTransaction_lift(_ buf: RustBuffer) throws -> Transaction {
    return try FfiConverterTypeTransaction.lift(buf)
}

public func FfiConverterTypeTransaction_lower(_ value: Transaction) -> RustBuffer {
    return FfiConverterTypeTransaction.lower(value)
}


public struct Transfer {
    public var `idx`: Int32
    public var `createdAt`: Int64
    public var `updatedAt`: Int64
    public var `status`: TransferStatus
    public var `amount`: UInt64
    public var `kind`: TransferKind
    public var `txid`: String?
    public var `recipientId`: String?
    public var `receiveUtxo`: Outpoint?
    public var `changeUtxo`: Outpoint?
    public var `expiration`: Int64?
    public var `transportEndpoints`: [TransferTransportEndpoint]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`idx`: Int32, `createdAt`: Int64, `updatedAt`: Int64, `status`: TransferStatus, `amount`: UInt64, `kind`: TransferKind, `txid`: String?, `recipientId`: String?, `receiveUtxo`: Outpoint?, `changeUtxo`: Outpoint?, `expiration`: Int64?, `transportEndpoints`: [TransferTransportEndpoint]) {
        self.`idx` = `idx`
        self.`createdAt` = `createdAt`
        self.`updatedAt` = `updatedAt`
        self.`status` = `status`
        self.`amount` = `amount`
        self.`kind` = `kind`
        self.`txid` = `txid`
        self.`recipientId` = `recipientId`
        self.`receiveUtxo` = `receiveUtxo`
        self.`changeUtxo` = `changeUtxo`
        self.`expiration` = `expiration`
        self.`transportEndpoints` = `transportEndpoints`
    }
}


extension Transfer: Equatable, Hashable {
    public static func ==(lhs: Transfer, rhs: Transfer) -> Bool {
        if lhs.`idx` != rhs.`idx` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`amount` != rhs.`amount` {
            return false
        }
        if lhs.`kind` != rhs.`kind` {
            return false
        }
        if lhs.`txid` != rhs.`txid` {
            return false
        }
        if lhs.`recipientId` != rhs.`recipientId` {
            return false
        }
        if lhs.`receiveUtxo` != rhs.`receiveUtxo` {
            return false
        }
        if lhs.`changeUtxo` != rhs.`changeUtxo` {
            return false
        }
        if lhs.`expiration` != rhs.`expiration` {
            return false
        }
        if lhs.`transportEndpoints` != rhs.`transportEndpoints` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`idx`)
        hasher.combine(`createdAt`)
        hasher.combine(`updatedAt`)
        hasher.combine(`status`)
        hasher.combine(`amount`)
        hasher.combine(`kind`)
        hasher.combine(`txid`)
        hasher.combine(`recipientId`)
        hasher.combine(`receiveUtxo`)
        hasher.combine(`changeUtxo`)
        hasher.combine(`expiration`)
        hasher.combine(`transportEndpoints`)
    }
}


public struct FfiConverterTypeTransfer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Transfer {
        return try Transfer(
            `idx`: FfiConverterInt32.read(from: &buf),
            `createdAt`: FfiConverterInt64.read(from: &buf),
            `updatedAt`: FfiConverterInt64.read(from: &buf),
            `status`: FfiConverterTypeTransferStatus.read(from: &buf),
            `amount`: FfiConverterUInt64.read(from: &buf),
            `kind`: FfiConverterTypeTransferKind.read(from: &buf),
            `txid`: FfiConverterOptionString.read(from: &buf),
            `recipientId`: FfiConverterOptionString.read(from: &buf),
            `receiveUtxo`: FfiConverterOptionTypeOutpoint.read(from: &buf),
            `changeUtxo`: FfiConverterOptionTypeOutpoint.read(from: &buf),
            `expiration`: FfiConverterOptionInt64.read(from: &buf),
            `transportEndpoints`: FfiConverterSequenceTypeTransferTransportEndpoint.read(from: &buf)
        )
    }

    public static func write(_ value: Transfer, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.`idx`, into: &buf)
        FfiConverterInt64.write(value.`createdAt`, into: &buf)
        FfiConverterInt64.write(value.`updatedAt`, into: &buf)
        FfiConverterTypeTransferStatus.write(value.`status`, into: &buf)
        FfiConverterUInt64.write(value.`amount`, into: &buf)
        FfiConverterTypeTransferKind.write(value.`kind`, into: &buf)
        FfiConverterOptionString.write(value.`txid`, into: &buf)
        FfiConverterOptionString.write(value.`recipientId`, into: &buf)
        FfiConverterOptionTypeOutpoint.write(value.`receiveUtxo`, into: &buf)
        FfiConverterOptionTypeOutpoint.write(value.`changeUtxo`, into: &buf)
        FfiConverterOptionInt64.write(value.`expiration`, into: &buf)
        FfiConverterSequenceTypeTransferTransportEndpoint.write(value.`transportEndpoints`, into: &buf)
    }
}


public func FfiConverterTypeTransfer_lift(_ buf: RustBuffer) throws -> Transfer {
    return try FfiConverterTypeTransfer.lift(buf)
}

public func FfiConverterTypeTransfer_lower(_ value: Transfer) -> RustBuffer {
    return FfiConverterTypeTransfer.lower(value)
}


public struct TransferTransportEndpoint {
    public var `endpoint`: String
    public var `transportType`: TransportType
    public var `used`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`endpoint`: String, `transportType`: TransportType, `used`: Bool) {
        self.`endpoint` = `endpoint`
        self.`transportType` = `transportType`
        self.`used` = `used`
    }
}


extension TransferTransportEndpoint: Equatable, Hashable {
    public static func ==(lhs: TransferTransportEndpoint, rhs: TransferTransportEndpoint) -> Bool {
        if lhs.`endpoint` != rhs.`endpoint` {
            return false
        }
        if lhs.`transportType` != rhs.`transportType` {
            return false
        }
        if lhs.`used` != rhs.`used` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`endpoint`)
        hasher.combine(`transportType`)
        hasher.combine(`used`)
    }
}


public struct FfiConverterTypeTransferTransportEndpoint: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferTransportEndpoint {
        return try TransferTransportEndpoint(
            `endpoint`: FfiConverterString.read(from: &buf),
            `transportType`: FfiConverterTypeTransportType.read(from: &buf),
            `used`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TransferTransportEndpoint, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`endpoint`, into: &buf)
        FfiConverterTypeTransportType.write(value.`transportType`, into: &buf)
        FfiConverterBool.write(value.`used`, into: &buf)
    }
}


public func FfiConverterTypeTransferTransportEndpoint_lift(_ buf: RustBuffer) throws -> TransferTransportEndpoint {
    return try FfiConverterTypeTransferTransportEndpoint.lift(buf)
}

public func FfiConverterTypeTransferTransportEndpoint_lower(_ value: TransferTransportEndpoint) -> RustBuffer {
    return FfiConverterTypeTransferTransportEndpoint.lower(value)
}


public struct Unspent {
    public var `utxo`: Utxo
    public var `rgbAllocations`: [RgbAllocation]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`utxo`: Utxo, `rgbAllocations`: [RgbAllocation]) {
        self.`utxo` = `utxo`
        self.`rgbAllocations` = `rgbAllocations`
    }
}


extension Unspent: Equatable, Hashable {
    public static func ==(lhs: Unspent, rhs: Unspent) -> Bool {
        if lhs.`utxo` != rhs.`utxo` {
            return false
        }
        if lhs.`rgbAllocations` != rhs.`rgbAllocations` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`utxo`)
        hasher.combine(`rgbAllocations`)
    }
}


public struct FfiConverterTypeUnspent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Unspent {
        return try Unspent(
            `utxo`: FfiConverterTypeUtxo.read(from: &buf),
            `rgbAllocations`: FfiConverterSequenceTypeRgbAllocation.read(from: &buf)
        )
    }

    public static func write(_ value: Unspent, into buf: inout [UInt8]) {
        FfiConverterTypeUtxo.write(value.`utxo`, into: &buf)
        FfiConverterSequenceTypeRgbAllocation.write(value.`rgbAllocations`, into: &buf)
    }
}


public func FfiConverterTypeUnspent_lift(_ buf: RustBuffer) throws -> Unspent {
    return try FfiConverterTypeUnspent.lift(buf)
}

public func FfiConverterTypeUnspent_lower(_ value: Unspent) -> RustBuffer {
    return FfiConverterTypeUnspent.lower(value)
}


public struct Utxo {
    public var `outpoint`: Outpoint
    public var `btcAmount`: UInt64
    public var `colorable`: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`outpoint`: Outpoint, `btcAmount`: UInt64, `colorable`: Bool) {
        self.`outpoint` = `outpoint`
        self.`btcAmount` = `btcAmount`
        self.`colorable` = `colorable`
    }
}


extension Utxo: Equatable, Hashable {
    public static func ==(lhs: Utxo, rhs: Utxo) -> Bool {
        if lhs.`outpoint` != rhs.`outpoint` {
            return false
        }
        if lhs.`btcAmount` != rhs.`btcAmount` {
            return false
        }
        if lhs.`colorable` != rhs.`colorable` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`outpoint`)
        hasher.combine(`btcAmount`)
        hasher.combine(`colorable`)
    }
}


public struct FfiConverterTypeUtxo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Utxo {
        return try Utxo(
            `outpoint`: FfiConverterTypeOutpoint.read(from: &buf),
            `btcAmount`: FfiConverterUInt64.read(from: &buf),
            `colorable`: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Utxo, into buf: inout [UInt8]) {
        FfiConverterTypeOutpoint.write(value.`outpoint`, into: &buf)
        FfiConverterUInt64.write(value.`btcAmount`, into: &buf)
        FfiConverterBool.write(value.`colorable`, into: &buf)
    }
}


public func FfiConverterTypeUtxo_lift(_ buf: RustBuffer) throws -> Utxo {
    return try FfiConverterTypeUtxo.lift(buf)
}

public func FfiConverterTypeUtxo_lower(_ value: Utxo) -> RustBuffer {
    return FfiConverterTypeUtxo.lower(value)
}


public struct WalletData {
    public var `dataDir`: String
    public var `bitcoinNetwork`: BitcoinNetwork
    public var `databaseType`: DatabaseType
    public var `maxAllocationsPerUtxo`: UInt32
    public var `pubkey`: String
    public var `mnemonic`: String?
    public var `vanillaKeychain`: UInt8?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`dataDir`: String, `bitcoinNetwork`: BitcoinNetwork, `databaseType`: DatabaseType, `maxAllocationsPerUtxo`: UInt32, `pubkey`: String, `mnemonic`: String?, `vanillaKeychain`: UInt8?) {
        self.`dataDir` = `dataDir`
        self.`bitcoinNetwork` = `bitcoinNetwork`
        self.`databaseType` = `databaseType`
        self.`maxAllocationsPerUtxo` = `maxAllocationsPerUtxo`
        self.`pubkey` = `pubkey`
        self.`mnemonic` = `mnemonic`
        self.`vanillaKeychain` = `vanillaKeychain`
    }
}


extension WalletData: Equatable, Hashable {
    public static func ==(lhs: WalletData, rhs: WalletData) -> Bool {
        if lhs.`dataDir` != rhs.`dataDir` {
            return false
        }
        if lhs.`bitcoinNetwork` != rhs.`bitcoinNetwork` {
            return false
        }
        if lhs.`databaseType` != rhs.`databaseType` {
            return false
        }
        if lhs.`maxAllocationsPerUtxo` != rhs.`maxAllocationsPerUtxo` {
            return false
        }
        if lhs.`pubkey` != rhs.`pubkey` {
            return false
        }
        if lhs.`mnemonic` != rhs.`mnemonic` {
            return false
        }
        if lhs.`vanillaKeychain` != rhs.`vanillaKeychain` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`dataDir`)
        hasher.combine(`bitcoinNetwork`)
        hasher.combine(`databaseType`)
        hasher.combine(`maxAllocationsPerUtxo`)
        hasher.combine(`pubkey`)
        hasher.combine(`mnemonic`)
        hasher.combine(`vanillaKeychain`)
    }
}


public struct FfiConverterTypeWalletData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WalletData {
        return try WalletData(
            `dataDir`: FfiConverterString.read(from: &buf),
            `bitcoinNetwork`: FfiConverterTypeBitcoinNetwork.read(from: &buf),
            `databaseType`: FfiConverterTypeDatabaseType.read(from: &buf),
            `maxAllocationsPerUtxo`: FfiConverterUInt32.read(from: &buf),
            `pubkey`: FfiConverterString.read(from: &buf),
            `mnemonic`: FfiConverterOptionString.read(from: &buf),
            `vanillaKeychain`: FfiConverterOptionUInt8.read(from: &buf)
        )
    }

    public static func write(_ value: WalletData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`dataDir`, into: &buf)
        FfiConverterTypeBitcoinNetwork.write(value.`bitcoinNetwork`, into: &buf)
        FfiConverterTypeDatabaseType.write(value.`databaseType`, into: &buf)
        FfiConverterUInt32.write(value.`maxAllocationsPerUtxo`, into: &buf)
        FfiConverterString.write(value.`pubkey`, into: &buf)
        FfiConverterOptionString.write(value.`mnemonic`, into: &buf)
        FfiConverterOptionUInt8.write(value.`vanillaKeychain`, into: &buf)
    }
}


public func FfiConverterTypeWalletData_lift(_ buf: RustBuffer) throws -> WalletData {
    return try FfiConverterTypeWalletData.lift(buf)
}

public func FfiConverterTypeWalletData_lower(_ value: WalletData) -> RustBuffer {
    return FfiConverterTypeWalletData.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AssetIface {
    
    case `rgb20`
    case `rgb25`
}

public struct FfiConverterTypeAssetIface: FfiConverterRustBuffer {
    typealias SwiftType = AssetIface

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetIface {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`rgb20`
        
        case 2: return .`rgb25`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetIface, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`rgb20`:
            writeInt(&buf, Int32(1))
        
        
        case .`rgb25`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeAssetIface_lift(_ buf: RustBuffer) throws -> AssetIface {
    return try FfiConverterTypeAssetIface.lift(buf)
}

public func FfiConverterTypeAssetIface_lower(_ value: AssetIface) -> RustBuffer {
    return FfiConverterTypeAssetIface.lower(value)
}


extension AssetIface: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AssetSchema {
    
    case `nia`
    case `cfa`
}

public struct FfiConverterTypeAssetSchema: FfiConverterRustBuffer {
    typealias SwiftType = AssetSchema

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetSchema {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`nia`
        
        case 2: return .`cfa`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetSchema, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`nia`:
            writeInt(&buf, Int32(1))
        
        
        case .`cfa`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeAssetSchema_lift(_ buf: RustBuffer) throws -> AssetSchema {
    return try FfiConverterTypeAssetSchema.lift(buf)
}

public func FfiConverterTypeAssetSchema_lower(_ value: AssetSchema) -> RustBuffer {
    return FfiConverterTypeAssetSchema.lower(value)
}


extension AssetSchema: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum BitcoinNetwork {
    
    case `mainnet`
    case `testnet`
    case `signet`
    case `regtest`
}

public struct FfiConverterTypeBitcoinNetwork: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetwork

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BitcoinNetwork {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`mainnet`
        
        case 2: return .`testnet`
        
        case 3: return .`signet`
        
        case 4: return .`regtest`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BitcoinNetwork, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`mainnet`:
            writeInt(&buf, Int32(1))
        
        
        case .`testnet`:
            writeInt(&buf, Int32(2))
        
        
        case .`signet`:
            writeInt(&buf, Int32(3))
        
        
        case .`regtest`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeBitcoinNetwork_lift(_ buf: RustBuffer) throws -> BitcoinNetwork {
    return try FfiConverterTypeBitcoinNetwork.lift(buf)
}

public func FfiConverterTypeBitcoinNetwork_lower(_ value: BitcoinNetwork) -> RustBuffer {
    return FfiConverterTypeBitcoinNetwork.lower(value)
}


extension BitcoinNetwork: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DatabaseType {
    
    case `sqlite`
}

public struct FfiConverterTypeDatabaseType: FfiConverterRustBuffer {
    typealias SwiftType = DatabaseType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DatabaseType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`sqlite`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DatabaseType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`sqlite`:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeDatabaseType_lift(_ buf: RustBuffer) throws -> DatabaseType {
    return try FfiConverterTypeDatabaseType.lift(buf)
}

public func FfiConverterTypeDatabaseType_lower(_ value: DatabaseType) -> RustBuffer {
    return FfiConverterTypeDatabaseType.lower(value)
}


extension DatabaseType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RefreshTransferStatus {
    
    case `waitingCounterparty`
    case `waitingConfirmations`
}

public struct FfiConverterTypeRefreshTransferStatus: FfiConverterRustBuffer {
    typealias SwiftType = RefreshTransferStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RefreshTransferStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`waitingCounterparty`
        
        case 2: return .`waitingConfirmations`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RefreshTransferStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`waitingCounterparty`:
            writeInt(&buf, Int32(1))
        
        
        case .`waitingConfirmations`:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRefreshTransferStatus_lift(_ buf: RustBuffer) throws -> RefreshTransferStatus {
    return try FfiConverterTypeRefreshTransferStatus.lift(buf)
}

public func FfiConverterTypeRefreshTransferStatus_lower(_ value: RefreshTransferStatus) -> RustBuffer {
    return FfiConverterTypeRefreshTransferStatus.lower(value)
}


extension RefreshTransferStatus: Equatable, Hashable {}



public enum RgbLibError {

    
    
    case AllocationsAlreadyAvailable
    case AssetNotFound(`assetId`: String)
    case BatchTransferNotFound(`txid`: String)
    case CannotChangeOnline
    case CannotDeleteTransfer
    case CannotFailTransfer
    case Electrum(`details`: String)
    case FailedBdkSync(`details`: String)
    case FailedBroadcast(`details`: String)
    case FailedIssuance(`details`: String)
    case FileAlreadyExists(`path`: String)
    case Io(`details`: String)
    case Inconsistency(`details`: String)
    case InexistentDataDir
    case InsufficientAllocationSlots
    case InsufficientBitcoins(`needed`: UInt64, `available`: UInt64)
    case InsufficientSpendableAssets(`assetId`: String)
    case InsufficientTotalAssets(`assetId`: String)
    case Internal(`details`: String)
    case InvalidAddress(`details`: String)
    case InvalidAmountZero
    case InvalidAssetId(`assetId`: String)
    case InvalidBitcoinKeys
    case InvalidBitcoinNetwork(`network`: String)
    case InvalidBlindedUtxo(`details`: String)
    case InvalidDescription(`details`: String)
    case InvalidElectrum(`details`: String)
    case InvalidFeeRate(`details`: String)
    case InvalidFilePath(`filePath`: String)
    case InvalidInvoice(`details`: String)
    case InvalidInvoiceData(`details`: String)
    case InvalidMnemonic(`details`: String)
    case InvalidName(`details`: String)
    case InvalidPrecision(`details`: String)
    case InvalidPsbt(`details`: String)
    case InvalidPubkey(`details`: String)
    case InvalidRecipientId
    case InvalidScript(`details`: String)
    case InvalidTicker(`details`: String)
    case InvalidTransportEndpoint(`details`: String)
    case InvalidTransportEndpoints(`details`: String)
    case InvalidVanillaKeychain
    case NoIssuanceAmounts
    case NoValidTransportEndpoint
    case Offline
    case OutputBelowDustLimit
    case Proxy(`details`: String)
    case RecipientIdAlreadyUsed
    case RecipientIdDuplicated
    case TooHighIssuanceAmounts
    case TransferNotFound(`recipientId`: String)
    case UnknownRgbInterface(`interface`: String)
    case UnknownRgbSchema(`schemaId`: String)
    case UnsupportedBackupVersion(`version`: String)
    case UnsupportedInvoice
    case UnsupportedTransportType
    case WatchOnly
    case WrongPassword

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeRgbLibError.lift(error)
    }
}


public struct FfiConverterTypeRgbLibError: FfiConverterRustBuffer {
    typealias SwiftType = RgbLibError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RgbLibError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .AllocationsAlreadyAvailable
        case 2: return .AssetNotFound(
            `assetId`: try FfiConverterString.read(from: &buf)
            )
        case 3: return .BatchTransferNotFound(
            `txid`: try FfiConverterString.read(from: &buf)
            )
        case 4: return .CannotChangeOnline
        case 5: return .CannotDeleteTransfer
        case 6: return .CannotFailTransfer
        case 7: return .Electrum(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 8: return .FailedBdkSync(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 9: return .FailedBroadcast(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 10: return .FailedIssuance(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 11: return .FileAlreadyExists(
            `path`: try FfiConverterString.read(from: &buf)
            )
        case 12: return .Io(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 13: return .Inconsistency(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 14: return .InexistentDataDir
        case 15: return .InsufficientAllocationSlots
        case 16: return .InsufficientBitcoins(
            `needed`: try FfiConverterUInt64.read(from: &buf),
            `available`: try FfiConverterUInt64.read(from: &buf)
            )
        case 17: return .InsufficientSpendableAssets(
            `assetId`: try FfiConverterString.read(from: &buf)
            )
        case 18: return .InsufficientTotalAssets(
            `assetId`: try FfiConverterString.read(from: &buf)
            )
        case 19: return .Internal(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 20: return .InvalidAddress(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 21: return .InvalidAmountZero
        case 22: return .InvalidAssetId(
            `assetId`: try FfiConverterString.read(from: &buf)
            )
        case 23: return .InvalidBitcoinKeys
        case 24: return .InvalidBitcoinNetwork(
            `network`: try FfiConverterString.read(from: &buf)
            )
        case 25: return .InvalidBlindedUtxo(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 26: return .InvalidDescription(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 27: return .InvalidElectrum(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 28: return .InvalidFeeRate(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 29: return .InvalidFilePath(
            `filePath`: try FfiConverterString.read(from: &buf)
            )
        case 30: return .InvalidInvoice(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 31: return .InvalidInvoiceData(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 32: return .InvalidMnemonic(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 33: return .InvalidName(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 34: return .InvalidPrecision(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 35: return .InvalidPsbt(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 36: return .InvalidPubkey(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 37: return .InvalidRecipientId
        case 38: return .InvalidScript(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 39: return .InvalidTicker(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 40: return .InvalidTransportEndpoint(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 41: return .InvalidTransportEndpoints(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 42: return .InvalidVanillaKeychain
        case 43: return .NoIssuanceAmounts
        case 44: return .NoValidTransportEndpoint
        case 45: return .Offline
        case 46: return .OutputBelowDustLimit
        case 47: return .Proxy(
            `details`: try FfiConverterString.read(from: &buf)
            )
        case 48: return .RecipientIdAlreadyUsed
        case 49: return .RecipientIdDuplicated
        case 50: return .TooHighIssuanceAmounts
        case 51: return .TransferNotFound(
            `recipientId`: try FfiConverterString.read(from: &buf)
            )
        case 52: return .UnknownRgbInterface(
            `interface`: try FfiConverterString.read(from: &buf)
            )
        case 53: return .UnknownRgbSchema(
            `schemaId`: try FfiConverterString.read(from: &buf)
            )
        case 54: return .UnsupportedBackupVersion(
            `version`: try FfiConverterString.read(from: &buf)
            )
        case 55: return .UnsupportedInvoice
        case 56: return .UnsupportedTransportType
        case 57: return .WatchOnly
        case 58: return .WrongPassword

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RgbLibError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .AllocationsAlreadyAvailable:
            writeInt(&buf, Int32(1))
        
        
        case let .AssetNotFound(`assetId`):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(`assetId`, into: &buf)
            
        
        case let .BatchTransferNotFound(`txid`):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(`txid`, into: &buf)
            
        
        case .CannotChangeOnline:
            writeInt(&buf, Int32(4))
        
        
        case .CannotDeleteTransfer:
            writeInt(&buf, Int32(5))
        
        
        case .CannotFailTransfer:
            writeInt(&buf, Int32(6))
        
        
        case let .Electrum(`details`):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .FailedBdkSync(`details`):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .FailedBroadcast(`details`):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .FailedIssuance(`details`):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .FileAlreadyExists(`path`):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(`path`, into: &buf)
            
        
        case let .Io(`details`):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .Inconsistency(`details`):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case .InexistentDataDir:
            writeInt(&buf, Int32(14))
        
        
        case .InsufficientAllocationSlots:
            writeInt(&buf, Int32(15))
        
        
        case let .InsufficientBitcoins(`needed`,`available`):
            writeInt(&buf, Int32(16))
            FfiConverterUInt64.write(`needed`, into: &buf)
            FfiConverterUInt64.write(`available`, into: &buf)
            
        
        case let .InsufficientSpendableAssets(`assetId`):
            writeInt(&buf, Int32(17))
            FfiConverterString.write(`assetId`, into: &buf)
            
        
        case let .InsufficientTotalAssets(`assetId`):
            writeInt(&buf, Int32(18))
            FfiConverterString.write(`assetId`, into: &buf)
            
        
        case let .Internal(`details`):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidAddress(`details`):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case .InvalidAmountZero:
            writeInt(&buf, Int32(21))
        
        
        case let .InvalidAssetId(`assetId`):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(`assetId`, into: &buf)
            
        
        case .InvalidBitcoinKeys:
            writeInt(&buf, Int32(23))
        
        
        case let .InvalidBitcoinNetwork(`network`):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(`network`, into: &buf)
            
        
        case let .InvalidBlindedUtxo(`details`):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidDescription(`details`):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidElectrum(`details`):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidFeeRate(`details`):
            writeInt(&buf, Int32(28))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidFilePath(`filePath`):
            writeInt(&buf, Int32(29))
            FfiConverterString.write(`filePath`, into: &buf)
            
        
        case let .InvalidInvoice(`details`):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidInvoiceData(`details`):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidMnemonic(`details`):
            writeInt(&buf, Int32(32))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidName(`details`):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidPrecision(`details`):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidPsbt(`details`):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidPubkey(`details`):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case .InvalidRecipientId:
            writeInt(&buf, Int32(37))
        
        
        case let .InvalidScript(`details`):
            writeInt(&buf, Int32(38))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidTicker(`details`):
            writeInt(&buf, Int32(39))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidTransportEndpoint(`details`):
            writeInt(&buf, Int32(40))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case let .InvalidTransportEndpoints(`details`):
            writeInt(&buf, Int32(41))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case .InvalidVanillaKeychain:
            writeInt(&buf, Int32(42))
        
        
        case .NoIssuanceAmounts:
            writeInt(&buf, Int32(43))
        
        
        case .NoValidTransportEndpoint:
            writeInt(&buf, Int32(44))
        
        
        case .Offline:
            writeInt(&buf, Int32(45))
        
        
        case .OutputBelowDustLimit:
            writeInt(&buf, Int32(46))
        
        
        case let .Proxy(`details`):
            writeInt(&buf, Int32(47))
            FfiConverterString.write(`details`, into: &buf)
            
        
        case .RecipientIdAlreadyUsed:
            writeInt(&buf, Int32(48))
        
        
        case .RecipientIdDuplicated:
            writeInt(&buf, Int32(49))
        
        
        case .TooHighIssuanceAmounts:
            writeInt(&buf, Int32(50))
        
        
        case let .TransferNotFound(`recipientId`):
            writeInt(&buf, Int32(51))
            FfiConverterString.write(`recipientId`, into: &buf)
            
        
        case let .UnknownRgbInterface(`interface`):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(`interface`, into: &buf)
            
        
        case let .UnknownRgbSchema(`schemaId`):
            writeInt(&buf, Int32(53))
            FfiConverterString.write(`schemaId`, into: &buf)
            
        
        case let .UnsupportedBackupVersion(`version`):
            writeInt(&buf, Int32(54))
            FfiConverterString.write(`version`, into: &buf)
            
        
        case .UnsupportedInvoice:
            writeInt(&buf, Int32(55))
        
        
        case .UnsupportedTransportType:
            writeInt(&buf, Int32(56))
        
        
        case .WatchOnly:
            writeInt(&buf, Int32(57))
        
        
        case .WrongPassword:
            writeInt(&buf, Int32(58))
        
        }
    }
}


extension RgbLibError: Equatable, Hashable {}

extension RgbLibError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransactionType {
    
    case `rgbSend`
    case `drain`
    case `createUtxos`
    case `user`
}

public struct FfiConverterTypeTransactionType: FfiConverterRustBuffer {
    typealias SwiftType = TransactionType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransactionType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`rgbSend`
        
        case 2: return .`drain`
        
        case 3: return .`createUtxos`
        
        case 4: return .`user`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransactionType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`rgbSend`:
            writeInt(&buf, Int32(1))
        
        
        case .`drain`:
            writeInt(&buf, Int32(2))
        
        
        case .`createUtxos`:
            writeInt(&buf, Int32(3))
        
        
        case .`user`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTransactionType_lift(_ buf: RustBuffer) throws -> TransactionType {
    return try FfiConverterTypeTransactionType.lift(buf)
}

public func FfiConverterTypeTransactionType_lower(_ value: TransactionType) -> RustBuffer {
    return FfiConverterTypeTransactionType.lower(value)
}


extension TransactionType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransferKind {
    
    case `issuance`
    case `receiveBlind`
    case `receiveWitness`
    case `send`
}

public struct FfiConverterTypeTransferKind: FfiConverterRustBuffer {
    typealias SwiftType = TransferKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`issuance`
        
        case 2: return .`receiveBlind`
        
        case 3: return .`receiveWitness`
        
        case 4: return .`send`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransferKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`issuance`:
            writeInt(&buf, Int32(1))
        
        
        case .`receiveBlind`:
            writeInt(&buf, Int32(2))
        
        
        case .`receiveWitness`:
            writeInt(&buf, Int32(3))
        
        
        case .`send`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTransferKind_lift(_ buf: RustBuffer) throws -> TransferKind {
    return try FfiConverterTypeTransferKind.lift(buf)
}

public func FfiConverterTypeTransferKind_lower(_ value: TransferKind) -> RustBuffer {
    return FfiConverterTypeTransferKind.lower(value)
}


extension TransferKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransferStatus {
    
    case `waitingCounterparty`
    case `waitingConfirmations`
    case `settled`
    case `failed`
}

public struct FfiConverterTypeTransferStatus: FfiConverterRustBuffer {
    typealias SwiftType = TransferStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransferStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`waitingCounterparty`
        
        case 2: return .`waitingConfirmations`
        
        case 3: return .`settled`
        
        case 4: return .`failed`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransferStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`waitingCounterparty`:
            writeInt(&buf, Int32(1))
        
        
        case .`waitingConfirmations`:
            writeInt(&buf, Int32(2))
        
        
        case .`settled`:
            writeInt(&buf, Int32(3))
        
        
        case .`failed`:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeTransferStatus_lift(_ buf: RustBuffer) throws -> TransferStatus {
    return try FfiConverterTypeTransferStatus.lift(buf)
}

public func FfiConverterTypeTransferStatus_lower(_ value: TransferStatus) -> RustBuffer {
    return FfiConverterTypeTransferStatus.lower(value)
}


extension TransferStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TransportType {
    
    case `jsonRpc`
}

public struct FfiConverterTypeTransportType: FfiConverterRustBuffer {
    typealias SwiftType = TransportType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransportType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`jsonRpc`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TransportType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`jsonRpc`:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeTransportType_lift(_ buf: RustBuffer) throws -> TransportType {
    return try FfiConverterTypeTransportType.lift(buf)
}

public func FfiConverterTypeTransportType_lower(_ value: TransportType) -> RustBuffer {
    return FfiConverterTypeTransportType.lower(value)
}


extension TransportType: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBlockTime: FfiConverterRustBuffer {
    typealias SwiftType = BlockTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBlockTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBlockTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOnline: FfiConverterRustBuffer {
    typealias SwiftType = Online?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOnline.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOnline.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeOutpoint: FfiConverterRustBuffer {
    typealias SwiftType = Outpoint?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOutpoint.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOutpoint.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeScriptData: FfiConverterRustBuffer {
    typealias SwiftType = ScriptData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeScriptData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeScriptData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAssetIface: FfiConverterRustBuffer {
    typealias SwiftType = AssetIface?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetIface.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetIface.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBitcoinNetwork: FfiConverterRustBuffer {
    typealias SwiftType = BitcoinNetwork?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBitcoinNetwork.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBitcoinNetwork.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAssetCFA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetCfa]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetCFA.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetCFA.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAssetNIA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetNia]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAssetNIA.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAssetNIA.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAssetCFA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetCfa]

    public static func write(_ value: [AssetCfa], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetCFA.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetCfa] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetCfa]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetCFA.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAssetNIA: FfiConverterRustBuffer {
    typealias SwiftType = [AssetNia]

    public static func write(_ value: [AssetNia], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetNIA.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetNia] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetNia]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetNIA.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeMedia: FfiConverterRustBuffer {
    typealias SwiftType = [Media]

    public static func write(_ value: [Media], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMedia.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Media] {
        let len: Int32 = try readInt(&buf)
        var seq = [Media]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMedia.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRecipient: FfiConverterRustBuffer {
    typealias SwiftType = [Recipient]

    public static func write(_ value: [Recipient], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRecipient.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Recipient] {
        let len: Int32 = try readInt(&buf)
        var seq = [Recipient]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRecipient.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRefreshFilter: FfiConverterRustBuffer {
    typealias SwiftType = [RefreshFilter]

    public static func write(_ value: [RefreshFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRefreshFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RefreshFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [RefreshFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRefreshFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRgbAllocation: FfiConverterRustBuffer {
    typealias SwiftType = [RgbAllocation]

    public static func write(_ value: [RgbAllocation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRgbAllocation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RgbAllocation] {
        let len: Int32 = try readInt(&buf)
        var seq = [RgbAllocation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRgbAllocation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransaction: FfiConverterRustBuffer {
    typealias SwiftType = [Transaction]

    public static func write(_ value: [Transaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransaction.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransfer: FfiConverterRustBuffer {
    typealias SwiftType = [Transfer]

    public static func write(_ value: [Transfer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransfer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Transfer] {
        let len: Int32 = try readInt(&buf)
        var seq = [Transfer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransfer.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTransferTransportEndpoint: FfiConverterRustBuffer {
    typealias SwiftType = [TransferTransportEndpoint]

    public static func write(_ value: [TransferTransportEndpoint], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTransferTransportEndpoint.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TransferTransportEndpoint] {
        let len: Int32 = try readInt(&buf)
        var seq = [TransferTransportEndpoint]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTransferTransportEndpoint.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUnspent: FfiConverterRustBuffer {
    typealias SwiftType = [Unspent]

    public static func write(_ value: [Unspent], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUnspent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Unspent] {
        let len: Int32 = try readInt(&buf)
        var seq = [Unspent]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUnspent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAssetSchema: FfiConverterRustBuffer {
    typealias SwiftType = [AssetSchema]

    public static func write(_ value: [AssetSchema], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAssetSchema.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AssetSchema] {
        let len: Int32 = try readInt(&buf)
        var seq = [AssetSchema]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAssetSchema.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringSequenceTypeRecipient: FfiConverterRustBuffer {
    public static func write(_ value: [String: [Recipient]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceTypeRecipient.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [Recipient]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [Recipient]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceTypeRecipient.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

public func `generateKeys`(`bitcoinNetwork`: BitcoinNetwork)  -> Keys {
    return try!  FfiConverterTypeKeys.lift(
        try! rustCall() {
    uniffi_rgb_lib_fn_func_generate_keys(
        FfiConverterTypeBitcoinNetwork.lower(`bitcoinNetwork`),$0)
}
    )
}

public func `restoreKeys`(`bitcoinNetwork`: BitcoinNetwork, `mnemonic`: String) throws -> Keys {
    return try  FfiConverterTypeKeys.lift(
        try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_func_restore_keys(
        FfiConverterTypeBitcoinNetwork.lower(`bitcoinNetwork`),
        FfiConverterString.lower(`mnemonic`),$0)
}
    )
}

public func `restoreBackup`(`backupPath`: String, `password`: String, `dataDir`: String) throws {
    try rustCallWithError(FfiConverterTypeRgbLibError.lift) {
    uniffi_rgb_lib_fn_func_restore_backup(
        FfiConverterString.lower(`backupPath`),
        FfiConverterString.lower(`password`),
        FfiConverterString.lower(`dataDir`),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_rgb_lib_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_rgb_lib_checksum_func_generate_keys() != 53799) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_func_restore_keys() != 43532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_func_restore_backup() != 22749) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_transportendpoint_transport_type() != 38883) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_invoice_invoice_data() != 30838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_invoice_invoice_string() != 902) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_backup() != 20993) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_backup_info() != 63633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_blind_receive() != 17097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_witness_receive() != 29684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_sign_psbt() != 8305) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_create_utxos() != 31926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_create_utxos_begin() != 4000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_create_utxos_end() != 13912) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_delete_transfers() != 43012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_drain_to() != 6563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_drain_to_begin() != 40327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_drain_to_end() != 26165) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_fail_transfers() != 16189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_get_address() != 24678) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_get_asset_balance() != 64863) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_get_btc_balance() != 4173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_get_asset_metadata() != 27386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_go_online() != 37329) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_issue_asset_nia() != 9784) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_issue_asset_cfa() != 51998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_list_assets() != 41445) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_list_transactions() != 41002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_list_transfers() != 28091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_list_unspents() != 48173) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_refresh() != 9624) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_send() != 27400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_send_begin() != 9845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_send_end() != 14109) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_method_wallet_send_btc() != 46442) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_constructor_blindedutxo_new() != 3614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_constructor_transportendpoint_new() != 40664) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_constructor_invoice_new() != 29839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_constructor_invoice_from_invoice_data() != 17537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_rgb_lib_checksum_constructor_wallet_new() != 19115) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
